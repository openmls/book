<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OpenMLS Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="message_validation.html"><strong aria-hidden="true">1.</strong> Message Validation</a></li><li class="chapter-item expanded "><a href="tree_rewrite.html"><strong aria-hidden="true">2.</strong> Tree Rewrite Project</a></li><li class="chapter-item expanded "><a href="type_enfored_verification.html"><strong aria-hidden="true">3.</strong> Type-Enforced Verification</a></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">4.</strong> Performance</a></li><li class="chapter-item expanded "><a href="forward_secrecy.html"><strong aria-hidden="true">5.</strong> Forward Secrecy</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OpenMLS Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="message-validation"><a class="header" href="#message-validation">Message Validation</a></h1>
<h2 id="validation-steps"><a class="header" href="#validation-steps">Validation steps</a></h2>
<ul>
<li>Syntax validation: This should be mostly covered by the decoding</li>
<li>Semantic validation: Checks to make sure a message is valid in a given context (signature verification, epoch number check, etc.)</li>
<li>Group policy validation: checks about handshake type, etc.</li>
<li>AS/policy validation: Checks to see whether syntactically and semantically correct messages should be adopted or dropped (Is a member allowed to add another member? Is a member allowed to remove another member?)</li>
</ul>
<h2 id="detailed-list-of-validation-steps"><a class="header" href="#detailed-list-of-validation-steps">Detailed list of validation steps</a></h2>
<h3 id="semantic-validation-of-message-framing"><a class="header" href="#semantic-validation-of-message-framing">Semantic validation of message framing</a></h3>
<table><thead><tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr></thead><tbody>
<tr><td><code>ValSem001</code></td><td>Wire format</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem002</code></td><td>Group id</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem003</code></td><td>Epoch</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem004</code></td><td>Sender: Member: check the sender points to a non-blank leaf</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem005</code></td><td>Application messages must use ciphertext</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem006</code></td><td>Ciphertext: decryption needs to work</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem007</code></td><td>Membership tag presence</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem008</code></td><td>Membership tag verification</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem009</code></td><td>Confirmation tag presence</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
<tr><td><code>ValSem010</code></td><td>Signature verification</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_validation.rs</code></td></tr>
</tbody></table>
<h3 id="semantic-validation-of-proposals-covered-by-a-commit"><a class="header" href="#semantic-validation-of-proposals-covered-by-a-commit">Semantic validation of proposals covered by a Commit</a></h3>
<table><thead><tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr></thead><tbody>
<tr><td><code>ValSem100</code></td><td>Add Proposal: Identity in proposals must be unique among proposals</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem101</code></td><td>Add Proposal: Signature public key in proposals must be unique among proposals</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem102</code></td><td>Add Proposal: HPKE init key in proposals must be unique among proposals</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem103</code></td><td>Add Proposal: Identity in proposals must be unique among existing group members</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem104</code></td><td>Add Proposal: Signature public key in proposals must be unique among existing group members</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem105</code></td><td>Add Proposal: HPKE init key in proposals must be unique among existing group members</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem106</code></td><td>Add Proposal: required capabilities</td><td>❌<sup>1</sup></td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem107</code></td><td>Remove Proposal: Removed member must be unique among proposals</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem108</code></td><td>Remove Proposal: Removed member must be an existing group member</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem109</code></td><td>Update Proposal: Identity must be unchanged between existing member and new proposal</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem110</code></td><td>Update Proposal: HPKE init key must be unique among existing members</td><td>✅</td><td>❌</td><td>TBD</td></tr>
</tbody></table>
<p><sup>1</sup> Partly implemented, see <code>TODO</code>s in <code>openmls/src/group/core_group/validation.rs</code>.</p>
<h3 id="commit-message-validation"><a class="header" href="#commit-message-validation">Commit message validation</a></h3>
<table><thead><tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr></thead><tbody>
<tr><td><code>ValSem200</code></td><td>Commit must not cover inline self Remove proposal</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem201</code></td><td>Path must be present, if Commit contains Removes or Updates</td><td>❌</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem202</code></td><td>Path must be the right length</td><td>❌</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem203</code></td><td>Path secrets must decrypt correctly</td><td>❌</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem204</code></td><td>Public keys from Path must be verified and match the private keys from the direct path</td><td>✅</td><td>❌</td><td>TBD</td></tr>
<tr><td><code>ValSem205</code></td><td>Confirmation tag must be successfully verified</td><td>✅</td><td>❌</td><td>TBD</td></tr>
</tbody></table>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p><em><a href="https://docs.google.com/document/d/1mtA7nqfh1v2guvh-7fGYEYAWaFDdLvf4i9n602RL0iE/edit?usp=sharing">temporary discussion doc</a></em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ManagedGroup {
  fn parse_message(&amp;mut self, mls_message: MlsMessage) -&gt; Result&lt;UnverifiedMessage, ManagedGroupError&gt; {
    /*
     - epoch must be within bounds
     - AAD can be extracted/evaluated
     - decryption
     - IFF content_type is a commit, confirmation_tag must be present
    */
  }

  fn process_unverified_message(&amp;self, message: UnverifiedMessage, signature_key: Option&lt;SignatureKey&gt;) -&gt; Result&lt;ProcessedMessage, ManagedGroupError&gt; {
    /*
     - Signature verification, either with leaf key or optional parameter
     - IF Commit:
       - Extract all inline &amp; pending proposals
     - Semantic validation of all proposals
       - IF Add Proposal: Double join check
       - IF Remove Proposal: Ghost removal check
       - IF Update Proposal: Identity must be unchanged
     - IF Commit:
       - Commit must not cover inline self Remove proposal
       - Path must be present, unless Commit only covers Add Proposals
       - Path must be the right length
       - Staging step: proposals must be applied to modify the provisional tree
       - Path must be applied and decrypt correctly
       - New public keys from Path must be verified and match the private keys from the direct path
       - Confirmation tag must be successfully verified
    */
  }

  fn store_pending_proposal(&amp;mut self, pending_proposal: PendingProposal) -&gt; () {
  /*
   - Store proposal in pending proposal list
  */
  }

  fn merge_staged_commit(&amp;mut self, staged_commit: StagedCommit, psks: &amp;[Psks]) -&gt; Result&lt;(), ManagedGroupError&gt; {
    /*
     - Merge staged Commit values into internal group stage
    */
  }
}

enum MlsMessage {
  Ciphertext(MlsCiphertext),
  Plaintext(MlsPlaintext),
}

impl UnverifiedMessage {
  fn aad(&amp;self) -&gt; &amp;[u8] {}
  fn credential(&amp;self) -&gt; &amp;Credential {}
}

enum ProcessedMessage {
  ApplicationMessage(Vec&lt;u8&gt;),
  ProposalMessage(PendingProposal),
  StagedCommitMessage(StagedCommit),
}

enum PendingProposal {
  Add(PendingAddProposal),
  Remove(PendingRemoveProposal),
  Update(PendingRemoveProposal),
  Psk(PendingPskProposal),
}

impl StagedCommit {
  fn adds(&amp;self) -&gt; &amp;[PendingAddProposal] {}
  fn removes(&amp;self) -&gt; &amp;[PendingRemoveProposal] {}
  fn updates(&amp;self) -&gt; &amp;[PendingUpdate] {}
  fn psks(&amp;self) -&gt; &amp;[PendingPskProposal] {}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="example-api-usage"><a class="header" href="#example-api-usage">Example API usage</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Parse either MlsPlaintext or MlsCiphertext
let unverified_message = group.pares_message(mls_message).expect(&quot;E1&quot;);

// Inspect AAD (optional)
if unverified_message.aad() == &amp;[1, 2, 3] {}

// Inspect credential and fetch signature key from AS (optional)
let signature_key = AuthenticationService::get_key(unverified_message.credential());

let processed_message = group.process_unverified_message(unverified_message, Some(signature_key)).expect(&quot;E2&quot;);

match processed_message {
  ApplicationMessage(bytes) =&gt; {
    // Do something with application message.
    // No further interaction with the group is needed.
  },
  ProposalMessage(pending_proposal) =&gt; {
    // We can optionally inspect the proposal before we store it in the group:
    match &amp;pending_proposal {
      Add(pending_add_proposal) =&gt; {
        // Do a policy check on that proposal
      },
      // Other type of propsals
      _ =&gt; {},
    }
    // After the optional inspection we store the pending proposal in the group
    group.store_pending_proposal(pending_proposal);
  }
  StagedCommitMessage(staged_commit) =&gt; {
    // We can optionally inspect all proposals covered by the Commit message before we merge it into the group:
    for add_proposal in &amp;staged_commit.adds() {
      // Inspect add proposals here
    }
    // Inspect PSKs and get them from a store:
    let psks = staged_commit.psks.iter().map(|p| PskStore::fetch_psk(p)).collect();
    // Merge the staged commit into the group
    group.merge_staged_commit(staged_commit, psks).expect(&quot;E3&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="legacy-stuff"><a class="header" href="#legacy-stuff">Legacy stuff</a></h1>
<h3 id="validation-function"><a class="header" href="#validation-function">Validation function</a></h3>
<p>The validation function has access to the inner state of a <code>ManagedGroup</code> and takes any inbound message from the DS as input. The messages are processed as follows:</p>
<h4 id="application-messages"><a class="header" href="#application-messages">Application messages</a></h4>
<p>The message is checked and marked as either valid or invalid.</p>
<h4 id="proposals"><a class="header" href="#proposals">Proposals</a></h4>
<p>The message is checked and marked as either valid or invalid. Proposals are stored inside a <code>ManagedGroup</code> and only evaluated when a Commit message is processed.</p>
<h4 id="commits"><a class="header" href="#commits">Commits</a></h4>
<p>The message is checked and marked as either valid, invalid or pending validation. If the Commit message covers proposals that require validation by the AS, a <code>PendingValidationMessage</code> type message is returned. The list of operations in that message covers all relevant proposals that were previously received in the current epoch.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ManagedGroup {
    ...
    fn validate(&amp;mut self, mls_message: MlsMessage) -&gt; EvaluatedMessage { ... }
    ...
}

enum MlsMessage {
    Plaintext(MlsPlaintext),
    Ciphertext(MlsCiphertext),
}

enum EvaluatedMessage {
    ValidMessage(ValidPlaintextMessage),
    PendingValidation(PendingValidationMessage),
    InvalidMessage(InvalidMessageDetails),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="valid-messages"><a class="header" href="#valid-messages">Valid messages</a></h3>
<p>Valid messages are either automatically valid if they passed all checks, or can be converted from <code>PendingValidationMessage</code> by manual validation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ValidPlaintextMessage(MlsPlaintext)
<span class="boring">}
</span></code></pre></pre>
<h3 id="messages-pending-validation"><a class="header" href="#messages-pending-validation">Messages pending validation</a></h3>
<p>Messages are marked as pending validation if input from the AS is required.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PendingValidationMessage {
    message: MlsPlaintext,
    operations: Vec&lt;OperationType&gt;,
}

impl PendingValidationMessage {
    fn validate(&amp;self) -&gt; ValidPlaintextMessage { ... }
}

enum OperationType {
    Add(AddOperation),
    Remove(RemoveOperation),
    Join(JoinOperation),
    Leave(LeaveOperation),
    Psk(PskOperation),
}

struct AddOperation { ... }
...
<span class="boring">}
</span></code></pre></pre>
<h3 id="invalid-messages"><a class="header" href="#invalid-messages">Invalid messages</a></h3>
<p>Messages that didn't pass the syntactic &amp; semantic checks are marked as invalid with a reason for their invalidity.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InvalidMessageDetails {
    sender: Option&lt;Sender&gt;,
    reason: InvalidMessageReason,
}

enum InvalidMessageReason {
    InvalidGroup,
    InvalidGeneration,
    InvalidCiphertext,
    InvalidSignature,
    InvalidMembershipTag,
    DoubleJoin,
    GhostRemoval,
    InvalidUpdate,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-rewrite-project"><a class="header" href="#tree-rewrite-project">Tree Rewrite Project</a></h1>
<p><img src="https://img.shields.io/badge/status-wip-orange.svg?style=for-the-badge" alt="" /></p>
<h2 id="treesync"><a class="header" href="#treesync">TreeSync</a></h2>
<p>TreeSync is a tree structure that keeps public data in a left-balanced binary
tree structure and relies on a KeyStore to store private data. Not every node
has to contain data. A node not containing data is considered blank. The
TreeSyncNode API determines how TreeSync interacts with the data it stores.</p>
<p><img src="./static/treesync_api.svg" alt="TreeSync Architecture" /></p>
<h4 id="node-indexing"><a class="header" href="#node-indexing">Node Indexing</a></h4>
<p>The current MLS spec explicitly relies on leaf- or node indices specific to the
array-representation of a tree to indicate individual nodes. Thus, to keep it
simple, this draft of a TreeSync API relies on the same indices.</p>
<p>In an actual implementation, we might have to translate from the array-specific
indices to whatever is used by the actual binary tree implementation underneath
<code>TreeSync</code>.</p>
<h3 id="treesyncnode-api"><a class="header" href="#treesyncnode-api">TreeSyncNode API</a></h3>
<p>TreeSync relies on the <code>TreeSyncNode</code> to represent the layer of abstraction
below it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TreeSyncNode {
    /// Return the value of the node relevant for the parent hash and tree hash.
    /// In case of MLS, this would be the node's HPKEPublicKey. TreeSync
    /// can then gather everything necessary to build the `ParentHashInput`,
    /// `LeafNodeHashInput` and `ParentNodeTreeHashInput` structs for a given node.
    fn node_content(&amp;self) -&gt; &amp;[u8] {}

    /// Get the list of unmerged leaves.
    fn unmerged_leaves(&amp;self) -&gt; &amp;[LeafIndex] {}

    /// Clear the list of unmerged leaves.
    fn clear_unmerged_leaves(&amp;mut self) {}

    /// Add a `LeafIndex` to the node's list of unmerged leaves.
    fn add_unmerged_leaf(&amp;mut self, LeafIndex) {}

    /// Set the parent hash value of this node.
    fn set_parent_hash(&amp;mut self, Vec&lt;u8&gt;) {}

    /// Get the parent hash value of this node.
    fn parent_hash(&amp;self) -&gt; &amp;[u8] {}

    /// Set the tree hash value for the given node.
    /// This assuming that the node caches the tree hash.
    fn set_tree_hash(&amp;mut self, Vec&lt;u8&gt;) {}

    /// Get the tree hash value for the given node.
    fn tree_hash(&amp;self) -&gt; &amp;[u8] {}

    /// Verify the signature on a given leaf node. Returns an
    /// error if called on a non-leaf node.
    fn verify(&amp;self) -&gt; Result&lt;bool, TreeSyncNodeError&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="treesync-api"><a class="header" href="#treesync-api">TreeSync API</a></h3>
<p>Note, that a majority of the tree operations are performed on TreeSyncDiffs (see
below).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TreeSync&lt;Node: TreeSyncNode, KeyStore: TreeSyncKeyStore&gt; {
    FLBBinaryTree&lt;Option&lt;Node&gt;&gt;
}

impl&lt;Node: TreeSyncNode, KeyStore: TreeSyncKeyStore&gt; TreeSync&lt;Node, KeyStore&gt; {
    /// Return the tree hash of the root node.
    fn tree_hash(&amp;self) -&gt; Vec&lt;u8&gt; {}

    /// Verify the parent hash of every parent node in the tree.
    fn verify_parent_hashes -&gt; Result&lt;(), TreeSyncError&gt; {}

    /// Merge the given diff into the `TreeSync` instance. This operation
    /// re-computes all necessary tree hashes.
    /// Note, that the private values corresponding to the ones in the
    /// TreeSync should be committed at the same time.
    fn merge_diff(&amp;mut self, tree_sync_diff: TreeSyncDiff) -&gt; Result&lt;(), TreeSyncError&gt; {}

    /// Create an empty diff based on this TreeSync instance all operations
    /// are created based on an initial, empty diff.
    fn empty_diff(&amp;self) -&gt; TreeSyncDiff {}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="treesyncdiffs"><a class="header" href="#treesyncdiffs">TreeSyncDiffs</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct&lt;Node: TreeSyncNode&gt; TreeSyncDiff&lt;Node&gt; {
    nodes: HashMap&lt;NodeIndex,Option&lt;Node&gt;&gt;,
}

impl&lt;Node: TreeSyncNode, KeyStore: TreeSyncKeyStore&gt; TreeSyncDiff&lt;Node&gt; {
    /// Update a leaf node and blank the nodes in the updated leaf's direct path.
    fn update_leaf(&amp;mut self, leaf_node: Node, leaf_index: LeafIndex) -&gt; TreeSyncDiff {}

    /// Adds a new leaf to the tree either by filling a blank leaf or by creating a new leaf,
    /// inserting intermediate blanks as necessary. This also adds the leaf_index of the new
    /// leaf to the `unmerged_leaves` state of the parent nodes in its direct path.
    fn add_leaf(&amp;mut self, leaf_node: Node) -&gt; Result&lt;TreeSyncDiff, TreeSyncError&gt; {}

    /// Remove a group member by blanking the target leaf and its direct path.
    fn remove_leaf(&amp;mut self, leaf_index: LeafIndex) -&gt; Result&lt;TreeSyncDiff, TreeSyncError&gt; {}

    /// Process a given update path, consisting of a vector of `Node`. This
    /// function
    /// * replaces the nodes in the direct path of the given `leaf_node` with the
    ///   the ones in `path` and
    /// * computes the `parent_hash` of all nodes in the path and compares it to the one in
    ///   the `leaf_node`.
    fn update_path(&amp;mut self, leaf_node: Node, path: Vec&lt;Node&gt;) -&gt; TreeSyncDiff {}

    /// Compute the tree hash of the TreeSync instance we would get when merging the diff.
    fn tree_hash(&amp;self) -&gt; Vec&lt;u8&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="treesync-usage-example"><a class="header" href="#treesync-usage-example">TreeSync Usage Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function demonstrates how TreeSync could be used to manage a tree and could be
/// used in create_commit to create a provisional tree and the
/// corresponding values (tree_hash, commit_secret, etc).
/// It returns the diff resulting from the operations applied to the TreeSync instance,
/// as well as the vector of `NodeSeed`s that can then be encrypted using TreeKEM.
/// Note, that the application with apply_commit is slightly asymmetrical, as we would potentially have
/// to pass in an additional `path` for TreeSync to apply.
fn apply_proposals(&amp;self, key_store: &amp;KeyStore, proposal_list: Vec&lt;Proposal&gt;) -&gt; Result&lt;(TreeSyncDiff), ApplyProposalsError&gt;{
    // ...
    // as Proposals are not generic, we have to translate them
    // individually to TreeSync operations
    // the assumption here is that the list of proposals is already
    // ordered by type and order as per commit
    let mut path_required = false;
    let mut my_new_key_package = None;
    let mut diff = self.tree_sync.empty_diff();
    for proposal in &amp;proposal_list {
        match proposal {
          Update(key_package) =&gt; {
              // If we process an update, we need to include a path in the end
              path_required = true;
              // We process self updates later using the update_path function
              if key_package.identity() != &amp;self.identity {
                  diff.update_leaf(key_package.into())
              } else {
                  my_new_key_package = Some(key_package)
              }
          },
          Add(key_package) =&gt; diff.add(TreeSyncNode::from(key_package)),
          // It's not clear yet how to expose &quot;identity&quot; to TreeSync.
          Remove(leaf_index) =&gt; {
              // If we process a remove, we need to include a path in the end
              path_required = true;
              diff.remove(leaf_index),
          }
        };
    }


    // If we want to create a path and/or one of the updates was a
    // self-update.
    if path_required || my_new_key_package.is_some() {
        // a path is required, but there's no explicit update, generate a new key_package
        if my_new_key_package.is_none() {
            my_new_key_package = key_store.generate_key_package_bundle(...);
        }
        // We assume that this function gives us the path based on the leaf_secret of the
        // key package bundle, which is in the key store.
        let (path, path_secrets) = create_path(&amp;key_store, &amp;my_new_key_package)?;
        // The private values generated in the process are put into the key store
        // This will compute the path secret and set it in the new leaf node.
        diff.update_path(TreeSyncLeafNode(my_new_key_package.unwrap()), path)?;
    } else {
        diff
    }

    // We can now call TreeKEM and encrypt the `path_secrets` (see below).
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="treekem-trait"><a class="header" href="#treekem-trait">TreeKEM Trait</a></h2>
<p>TreeKEM would take one of the &quot;node seed&quot; discussed above and encrypt/decrypt
it. For encryption/decryption it would need access to a TreeSync instance, where
<code>Node</code> implements <code>TreeKemNode</code>, which in turn provides the functions that
TreeKEM needs. In particular, it would have to provide access to the public keys
of each node.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TreeKemNode&lt;KeyStore: TreeSyncKeyStore&gt; {
    /// Encrypt a given plaintext to the node's public key.
    fn encrypt(&amp;self, plaintext: &amp;[u8]) -&gt; HpkeCiphertext {}

    /// Decrypt a given ciphertext using the secret key corresponding to the node.
    fn decrypt(&amp;self, key_store: &amp;KeyStore, ciphertext: &amp;HpkeCiphertext) -&gt; Vec&lt;u8&gt; {}
}

trait&lt;KeyStore: TreeSyncKeyStore&gt; TreeKem&lt;KeyStore&gt; {
    /// Create an UpdatePath by encrypting a vector of `NodeSeed`s
    /// to the direct path of our own leaf.
    fn encrypt_path(&amp;self, path: Vec&lt;NodeSeed&gt;) -&gt; Result&lt;UpdatePath, TreeKemError&gt; {}

    /// Decrypt an UpdatePath, returning the `NodeSeed` and the vector of `Node`s.
    fn decrypt_path(&amp;self, key_store: KeyStore, update_path: UpdatePath) -&gt; Result&lt;(NodeSeed, Vec&lt;Node&gt;), TreeKemError&gt; {}
}

<span class="boring">}
</span></code></pre></pre>
<p>Questions:</p>
<ul>
<li>Should we allow TreeKEM to know about KeyPackages or do we draw the
abstraction line at public keys? It needs to know about KeyPackages to be able
to return an UpdatePath. Otherwise it would be a vector of UpdatePathNode.</li>
</ul>
<p>TODO: Create a KeyStore API for TreeKem. See https://github.com/franziskuskiefer/key-store-rs/blob/main/src/traits.rs</p>
<h3 id="keystore-api-old-api-for-treesync"><a class="header" href="#keystore-api-old-api-for-treesync">KeyStore API (old API for TreeSync)</a></h3>
<p>TreeSync requires a place in which to store secrets and private keys. In
particular, it should store:</p>
<ul>
<li>Pairs of <code>(PrivateState, NodeSeed)</code> indexed by <code>PrivateStateHandle</code> for updates to one's own leaf node. These
are independent of a given group and get consumed when used.</li>
<li>A <code>NodeSeed</code>, which represents the <code>CommitSecret</code> in MLS-terms.</li>
<li>A number of <code>PrivateState</code>, representing the private values of the nodes in
one's own direct path, indexed by Node indices. This includes the
<code>PrivateState</code> of the leaf.</li>
<li>A temporary <code>Vec&lt;PrivateState&gt;</code>, for the private part of a provisional
TreeSync state.</li>
<li>A temporary <code>NodeSeed</code>, for the private part of a provisional TreeSync state.</li>
</ul>
<p>The individual get and erase functions allow the persistence of derivations of
the <code>NodeSeed</code> before deleting it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TreeSyncKeyStore&lt;Node: TreeSyncNode&gt; {
    /// Store a pair of `Node::NodeSeed` and `Node::PrivateState` corresponding to a
    /// `Node` meant to be used as a leaf node in a future update. Note, that
    /// the `Node::NodeSeed` will only be used if we commit the update ourselves.
    fn store_leaf_node_private_state(&amp;mut self, node_seed: Node::NodeSeed, private_values: Node::PrivateState) {}

    /// Take a pair of `Node::NodeSeed` and `Node::PrivateState` corresponding to a
    /// `Node::PrivatStateHandle`, thereby removing it from the store.
    fn take_leaf_node_private_state(&amp;mut self, handle: Node::PrivateStateHandle) -&gt; Result&lt;(Node::NodeSeed, Node:: PrivateState), KeyStoreError&gt; {}

    /// Store the temporary `Vec&lt;Node::PrivateState&gt;` and `Node::NodeSeed`.
    fn store_temporary_private_states(&amp;mut self, private_values: (Vec&lt;Node::PrivateState&gt;, Node::NodeSeed)) {}

    /// Commit to the current temporary `Vec&lt;Node::PrivateState&gt;` and `Node::NodeSeed`
    /// by using it to overwrite the corresponding non-temporary values.
    fn commit_to_temporary_values(&amp;mut self) {}

    /// Get the `Node::NodeSeed`. Note, that it should be removed using
    /// `erase_node_seed` after it was used.
    fn node_seed(&amp;self) -&gt; Node::NodeSeed {}

    /// Get the `Node::NodeSeed`. Note, that it should be removed using
    /// `erase_node_seed` after it was used.
    fn erase_node_seed(&amp;mut self) {}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="binary-tree-api"><a class="header" href="#binary-tree-api">Binary Tree API</a></h2>
<p><code>TreeSync</code>, <code>TreeKEM</code> and <code>TreeDEM</code> rely on an underlying full, left-balenced
binary tree representation <code>FLBBinaryTree</code> to organise its data and to process
it.</p>
<p>As discussed above, the following binary tree API relies on the indices of an
array-based binary tree representation. While the binary tree implementation
needs to provide an interface based on these indices, it does not necessarily
need to organise the data in memory in the style of the array-representation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FLBBinaryTree&lt;Node&gt; {
    /// Obtain a reference to the data contained in the `Node` at index `node_index`.
    /// Returns an error if the index is outside of the tree.
    fn node(&amp;self, node_index: NodeIndex) -&gt; Result&lt;&amp;Node, FLBBBinaryTreeError&gt; {}

    /// Obtain a mutable reference to the data contained in the `Node` at index `node_index`.
    /// Returns an error if the index is outside of the tree.
    fn node_mut(&amp;mut self, node_index: NodeIndex) -&gt; Result&lt;&amp;mut Node, FLBBBinaryTreeError&gt; {}

    /// Add two nodes to the right side of the tree. Nodes can only be
    /// added in pairs to keep the tree full.
    fn add(&amp;mut self, node_1:Node , node_2: Node) -&gt; Result&lt;(), FLBBBinaryTreeError&gt; {}

    /// Remove the two rightmost nodes of the tree.
    fn remove(&amp;mut self) -&gt; Result&lt;(), FLBBBinaryTreeError&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="open-questionstodos"><a class="header" href="#open-questionstodos">Open Questions/TODOs:</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
What's the <code>BinaryTree</code> API? (FK)
<ul>
<li>Added a secion on full, left-balanced BinaryTree API. It leaves a lot of
functionality in <code>TreeSync</code>, but it keeps the interface simple and small.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
How do diffs work with the key store? (FK)
<ul>
<li>There's now a TreeSync specific KeyStore API that includes temporary values.</li>
</ul>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Write an example of what kind of secrets we want to store and when, as
well as what kind of secrets we want to delete and when.</li>
<li><input disabled="" type="checkbox"/>
Store secrets based on group + epoch.</li>
<li><input disabled="" type="checkbox"/>
Implement CRUD interface.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
What's the most efficient data structure for <code>TreeSyncDiff</code>? (FK)
<ul>
<li>If it's a vector, the elements should get a struct.</li>
<li>Initial idea is to make it a <code>HashMap&lt;NodeIndex,TreeSyncNode&gt;</code></li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Does any of these structs need internal mutability? (FK)</li>
<li><input disabled="" type="checkbox"/>
Should there be shared functionality for diffs? (FK)</li>
<li><input disabled="" type="checkbox"/>
<code>TreeSync</code> should have a cache for hashes. (FK)
<ul>
<li>The current design requires the underlying nodes to do the hashing.
Not sure if that's the optimal approach.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Design API for TreeDEM</li>
<li><input disabled="" type="checkbox"/>
Rework Diff types to be abstract and independent of the binary tree implementation
<ul>
<li>We have the same argument here as for MLS. We need some way to address individual nodes
and we use indices from the array-based representation for that. As long as the underlying
binary tree maps that to the underlying memory model, it should work fine.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Do we want persistence for diffs?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-enforced-verification"><a class="header" href="#type-enforced-verification">Type-Enforced Verification</a></h1>
<p>We use Rust's type checker to achieve additional security guarantees regarding
the signing and verification of structs. There are four traits:</p>
<ul>
<li><code>Signable</code>: A payload that the sender/signer of a message can create. The
trait provides a <code>sign</code> function that produces a <code>SignedStruct</code>.</li>
<li><code>SignedStruct</code>: The result of signing a <code>Signable</code> struct. This struct can
actually be encoded and sent over the wire. The <code>SignedStruct</code> does not
necessarily contain all the information required to sign or verify the struct.</li>
<li><code>Verifiable</code>: A payload, potentially received from the wire with a signature
and all information required to verify the struct. When receiving a
<code>SignedStruct</code>, the receiver can add additional information required to make
the struct verifiable. Provides a <code>verify</code> function.</li>
<li><code>VerifiedStruct</code>: The result of calling the <code>verify</code> function on a
<code>Verifiable</code> struct. The <code>VerifiedStruct</code> is what is accepted by further
processing functions on the receiving side.</li>
</ul>
<p><img src="./static/signable.svg" alt="Traits around signing and verification in OpenMLS." /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<p>How does OpenMLS (and MLS in general) perform in different settings?</p>
<p>Performance measurements are implemented <a href="https://github.com/openmls/openmls/blob/franziskus/benchmarks/benches/group.rs">here</a> and can be run with <code>cargo bench --bench group</code>.
Make sure that check in the code which scenarios and group sizes are enabled.</p>
<p><a href="https://docs.google.com/spreadsheets/d/1nZv8lpT28JctDVo4ARBLZCKcIdvo-h8cIyN3_dIedFU">OpenMLS Performance Spreadsheet</a></p>
<h2 id="real-world-scenarios"><a class="header" href="#real-world-scenarios">Real World Scenarios</a></h2>
<h3 id="stable-group"><a class="header" href="#stable-group">Stable group</a></h3>
<p>Many private groups follow this model</p>
<ul>
<li>Group is created by user P1</li>
<li>P1 invites a set of N other users</li>
<li>The group is used for messaging between the N+1 members</li>
<li>Every X messages one user in the group sends an update</li>
</ul>
<h3 id="somewhat-stable-group"><a class="header" href="#somewhat-stable-group">Somewhat stable group</a></h3>
<p>This can model a company or team wide group where regularly but infrequently users are added and users leave</p>
<ul>
<li>Group is created by user P1</li>
<li>P1 invites a set of N other users</li>
<li>The group is used for messaging between the members</li>
<li>Every X messages one user in the group sends an update</li>
<li>Every Y messages Q users are added</li>
<li>Every Z messages R users are removed</li>
</ul>
<h3 id="high-fluctuation-group"><a class="header" href="#high-fluctuation-group">High fluctuation group</a></h3>
<p>This models public groups where users frequently join and leave.
Real-time scenarios such as <a href="https://gather.town">gather.town</a> are an example of high fluctuation groups.
It is the same scenario as the somewhat stable group but with a very small Y, Z.</p>
<h2 id="extreme-scenarios"><a class="header" href="#extreme-scenarios">Extreme Scenarios</a></h2>
<p>In addition to the three scenarios above extreme and corner cases are interesting.</p>
<h3 id="every-second-leave-is-blank"><a class="header" href="#every-second-leave-is-blank">Every second leave is blank</a></h3>
<p>Only every second leave in the tree is non-blank.</p>
<h2 id="use-case-scenarios"><a class="header" href="#use-case-scenarios">Use Case Scenarios</a></h2>
<p>A collection of common use cases/flows.</p>
<h3 id="long-time-offline-device"><a class="header" href="#long-time-offline-device">Long-time offline device</a></h3>
<p>If a device has been offline for a while, it has to process a large number of application and protocol messages.</p>
<h2 id="tree-scenarios"><a class="header" href="#tree-scenarios">Tree scenarios</a></h2>
<p>In addition the scenarios above it is interesting to look at the same scenario but with different states of the tree.
For example, take the stable group with N members messaging each other.
How is the performance different between a message sent right after group setup, i.e. each member only joined the group without other messages being sent, and a tree where every member has sent an update before the message?</p>
<h2 id="measurements"><a class="header" href="#measurements">Measurements</a></h2>
<ul>
<li>Group creation
<ul>
<li>create group</li>
<li>create proposals</li>
<li>create welcome</li>
<li>apply commit</li>
</ul>
</li>
<li>Join group
<ul>
<li>create group from welcome</li>
</ul>
</li>
<li>Send application message</li>
<li>Receive application message</li>
<li>Send update
<ul>
<li>create proposal</li>
<li>create commit</li>
<li>apply commit</li>
</ul>
</li>
<li>Receive update
<ul>
<li>apply commit</li>
</ul>
</li>
<li>Add user sender
<ul>
<li>create proposal</li>
<li>create welcome</li>
<li>apply commit</li>
</ul>
</li>
<li>Existing user getting an add
<ul>
<li>apply commit</li>
</ul>
</li>
<li>Remove user sender
<ul>
<li>create proposal</li>
<li>create commit</li>
<li>apply commit</li>
</ul>
</li>
<li>Existing user getting a remove
<ul>
<li>apply commit</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forward-secrecy"><a class="header" href="#forward-secrecy">Forward Secrecy</a></h1>
<p>To achieve forward secrecy, OpenMLS drops key material immediately after a given
key is no longer required by the protocol. For some keys this is simple, as they
are used only once and there is no need to store them for later use. However,
for other keys, the time of deletion is a result of a trade-off between
functionality and forward secrecy. For example, it can be desirable to keep the
<code>SecretTree</code> of past epochs for a while to allow decryption of straggling
application messages sent in previous epochs.</p>
<p>In this chapter, we detail how we achieve forward secrecy for the different types of keys used throughout MLS.</p>
<h2 id="ratchet-tree"><a class="header" href="#ratchet-tree">Ratchet Tree</a></h2>
<p>The ratchet tree contains the secret key material of the client's leaf, as well
(potentially) that of nodes in its direct path. The secrets in the tree are
changed in the same way as the tree itself: via the merge of a previously
prepared diff.</p>
<h3 id="commit-creation"><a class="header" href="#commit-creation">Commit Creation</a></h3>
<p>Upon the creation of a commit, any fresh key material introduced by the
committer is stored in the diff. It exists alongside the key material of the
ratchet tree before the commit until the client merges the diff, upon which the
key material in the original ratchet tree is dropped.</p>
<h3 id="commit-processing"><a class="header" href="#commit-processing">Commit Processing</a></h3>
<p>Upon receiving a commit from another group member, the client processes the
commit until they have a <code>StagedCommit</code>, which in turn contains a ratchet tree
diff. The diff contains any potential key material they decrypted from the
commit, as well as any potential key material that was introduced to the tree as
part of an update that someone else committed for them. The key material in the
original ratchet tree is dropped as soon as the <code>StagedCommit</code> (and thus the
diff) is merged into the tree.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
