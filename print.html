<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OpenMLS Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="user_manual/index.html"><strong aria-hidden="true">1.</strong> User manual</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="user_manual/identity.html"><strong aria-hidden="true">1.1.</strong> Credentials</a></li><li class="chapter-item expanded "><a href="user_manual/create_key_package.html"><strong aria-hidden="true">1.2.</strong> Key packages</a></li><li class="chapter-item expanded "><a href="user_manual/group_config.html"><strong aria-hidden="true">1.3.</strong> Group configuration</a></li><li class="chapter-item expanded "><a href="user_manual/create_group.html"><strong aria-hidden="true">1.4.</strong> Creating groups</a></li><li class="chapter-item expanded "><a href="user_manual/join_from_welcome.html"><strong aria-hidden="true">1.5.</strong> Join a group from a Welcome message</a></li><li class="chapter-item expanded "><a href="user_manual/add_members.html"><strong aria-hidden="true">1.6.</strong> Adding members to a group</a></li><li class="chapter-item expanded "><a href="user_manual/remove_members.html"><strong aria-hidden="true">1.7.</strong> Removing members from a group</a></li><li class="chapter-item expanded "><a href="user_manual/updates.html"><strong aria-hidden="true">1.8.</strong> Updating own key package</a></li><li class="chapter-item expanded "><a href="user_manual/leaving.html"><strong aria-hidden="true">1.9.</strong> Leaving a group</a></li><li class="chapter-item expanded "><a href="user_manual/application_messages.html"><strong aria-hidden="true">1.10.</strong> Creating application messages</a></li><li class="chapter-item expanded "><a href="user_manual/commit_to_proposals.html"><strong aria-hidden="true">1.11.</strong> Committing to pending proposals</a></li><li class="chapter-item expanded "><a href="user_manual/processing.html"><strong aria-hidden="true">1.12.</strong> Processing incoming messages</a></li><li class="chapter-item expanded "><a href="user_manual/persistence.html"><strong aria-hidden="true">1.13.</strong> Persistenc of group state</a></li></ol></li><li class="chapter-item expanded "><a href="traits/index.html"><strong aria-hidden="true">2.</strong> Traits &amp; External Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="traits/traits.html"><strong aria-hidden="true">2.1.</strong> Traits</a></li><li class="chapter-item expanded "><a href="traits/types.html"><strong aria-hidden="true">2.2.</strong> Types</a></li></ol></li><li class="chapter-item expanded "><a href="message_validation.html"><strong aria-hidden="true">3.</strong> Message Validation</a></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">4.</strong> Performance</a></li><li class="chapter-item expanded "><a href="forward_secrecy.html"><strong aria-hidden="true">5.</strong> Forward Secrecy</a></li><li class="chapter-item expanded "><a href="release_management.html"><strong aria-hidden="true">6.</strong> Release management</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OpenMLS Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<!-- Get the Readme without the headline until (including) the introductory sentence  -->
<p><a href="https://openmls.zulipchat.com"><img src="https://img.shields.io/badge/zulip-join_chat-blue.svg?style=for-the-badge&amp;logo=zulip" alt="OpenMLS Chat" /></a>
<a href="https://groups.google.com/u/0/g/openmls-dev"><img src="https://img.shields.io/badge/mailing-list-blue.svg?style=for-the-badge" alt="OpenMLS List" /></a></p>
<p><a href="https://github.com/openmls/openmls/actions/workflows/tests.yml"><img src="https://img.shields.io/github/workflow/status/openmls/openmls/Tests/main?label=Tests&amp;style=for-the-badge&amp;logo=github" alt="Tests &amp; Checks" /></a>
<a href="https://cloud.drone.io/openmls/openmls"><img src="https://img.shields.io/drone/build/openmls/openmls/main?label=ARM64%20Build%20Status&amp;logo=drone&amp;style=for-the-badge" alt="ARM64 Build Status" /></a>
<a href="https://codecov.io/gh/openmls/openmls"><img src="https://img.shields.io/codecov/c/github/openmls/openmls/main?logo=codecov&amp;style=for-the-badge" alt="codecov" /></a></p>
<p><a href="https://docs.rs/crate/openmls/latest"><img src="https://img.shields.io/badge/docs-release-blue.svg?style=for-the-badge" alt="Docs" /></a>
<a href="https://openmls.tech/book"><img src="https://img.shields.io/badge/book-release-blue.svg?style=for-the-badge" alt="Book" /></a>
<img src="https://img.shields.io/badge/rustc-1.56+-blue.svg?style=for-the-badge&amp;logo=rust" alt="Rust Version" /></p>
<p><em>OpenMLS</em> is a Rust implementation of <a href="https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md">Messaging Layer Security</a> based on draft 12+.
OpenMLS provides a high-level API to create and manage MLS groups. It supports basic ciphersuites, as well as an interchangable cryptographic backend, key store and random number generator.</p>
<p>This book provides guidance on how to use OpenMLS and its <code>MlsGroup</code> API to perform basic group operations, illustrated with examples.</p>
<!-- Get the rest of the Readme -->
<h2 id="supported-ciphersuites"><a class="header" href="#supported-ciphersuites">Supported ciphersuites</a></h2>
<ul>
<li>MLS10_128_HPKEX25519_AES128GCM_SHA256_Ed25519 (MTI)</li>
<li>MLS10_128_DHKEMP256_AES128GCM_SHA256_P256</li>
<li>MLS10_128_HPKEX25519_CHACHA20POLY1305_SHA256_Ed25519</li>
</ul>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported platforms</a></h2>
<p>OpenMLS is built and tested on the Github CI for the following rust targets.</p>
<ul>
<li>x86_64-unknown-linux-gnu</li>
<li>i686-unknown-linux-gnu</li>
<li>x86_64-pc-windows-msvc</li>
<li>i686-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
</ul>
<p>Additionally, we're building and testing aarch64-unknown-linux-gnu on
<a href="https://cloud.drone.io/openmls/openmls">drone.io</a>.</p>
<p>The Github CI also builds (but doesn't test) the following rust targets.</p>
<ul>
<li>aarch64-apple-darwin</li>
<li>aarch64-unknown-linux-gnu</li>
<li>aarch64-linux-android</li>
<li>aarch64-apple-ios</li>
<li>aarch64-apple-ios-sim</li>
<li>wasm32-unknown-unknown</li>
</ul>
<p>OpenMLS supports 32 bit platforms and above.</p>
<h2 id="cryptography-dependencies"><a class="header" href="#cryptography-dependencies">Cryptography Dependencies</a></h2>
<p>OpenMLS does not implement its own cryptographic primitives. Instead, it relies
on existing implementations of the cryptographic primitives used by MLS. There
are two different cryptography backends implemented right now. But consumers
can bring their own implementation. See <a href="https://github.com/openmls/openmls/tree/main/traits">traits</a> for more
details.</p>
<h2 id="working-on-openmls"><a class="header" href="#working-on-openmls">Working on OpenMLS</a></h2>
<p>For more details when working on OpenMLS itself please see the <a href="https://github.com/openmls/openmls/blob/main/Developer.md">Developer.md</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-manual"><a class="header" href="#user-manual">User manual</a></h1>
<p>The user manual describes how to use the different parts of the OpenMLS API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credentials"><a class="header" href="#credentials">Credentials</a></h1>
<p>MLS relies on credentials to encode the identity of clients in the context of a group. There are different types of credentials, with the OpenMLS library currently only supporting the <code>BasicCredential</code> credential type (see below). All credentials have in common that they contain a signature public key (with the owner of the credential holding the corresponding private key) which is used to authenticate messages by the owner in the context of one or more groups.</p>
<p>A credential is always embedded in a <a href="user_manual/./create_key_package.html">key package</a>, which is ultimately used to represent a client in a group and which is signed by the private key corresponding to the signature public key of the credential it contains. Clients can decide to use the same credential in multiple key packages (and thus multiple groups) or to use distinct credential per key package.</p>
<p>The binding between a given credential and owning client's identity is in turn authenticated by the Authentication Service, an abstract authentication layer defined by the <a href="https://github.com/mlswg/mls-architecture">MLS architecture document</a>. Note, that the implementation of the Authentication Service and thus the details of how the binding is authenticated is not specified by MLS.</p>
<h2 id="creating-and-using-credentials"><a class="header" href="#creating-and-using-credentials">Creating and using credentials</a></h2>
<p>OpenMLS allows clients to create <code>CredentialBundles</code>, each bundling a credential and the private key corresponding to the signature public key inside it. A <code>BasicCredential</code>, which is currently the only credential type supported by MLS, consists only of the <code>identity</code>, an opaque byte-vector, as well as the signature public key and the corresponding signature scheme. Thus, to create a fresh <code>CredentialBundle</code>, the following inputs are required:</p>
<ul>
<li><code>identity: Vec&lt;u8&gt;</code>: An octet string that uniquely identifies the client.</li>
<li><code>credential_type: CredentialType</code>: The type of the credential, in this case <code>CredentialType::Basic</code>.</li>
<li><code>signature_scheme: SignatureScheme</code>: The signature scheme of the signature keypair, e.g. <code>SignatureScheme::ED25519</code>.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    let credential_bundle =
        CredentialBundle::new(identity, credential_type, signature_algorithm, backend)?;
</code></pre>
<p>After creating the credential bundle, clients should store it in the key store so that it can be automatically retrieved when performing a group operation through the <code>MlsGroup</code> API that requires the client to sign a message.</p>
<pre><code class="language-rust no_run noplayground">    let credential = credential_bundle.credential().clone();
    backend
        .key_store()
        .store(
            &amp;credential
                .signature_key()
                .tls_serialize_detached()
                .expect(&quot;Error serializing signature key.&quot;),
            &amp;credential_bundle,
        )
        .expect(&quot;An unexpected error occurred.&quot;);
</code></pre>
<p>All functions and structs related to credentials can be found in the <a href="https://docs.rs/crate/openmls/latest/credentials/index.html"><code>credentials</code></a> module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-packages"><a class="header" href="#key-packages">Key packages</a></h1>
<p>To enable asynchronous establishment of groups through pre-publishing key material, as well as to represent clients in group, MLS relies on key packages. Key packages hold a number of pieces of information:</p>
<ul>
<li>a public HPKE encryption key to enable MLS' basic group key distribution feature</li>
<li>the life time throughout which the key package is valid</li>
<li>information about the client's capabilities (i.e. which features of MLS it supports)</li>
<li>any extension that the client wants to include</li>
<li>one of the client's <a href="user_manual/./identity.html">credentials</a>, as well as a signature over the whole key package using the private key corresponding to the credential's signature public key</li>
</ul>
<h2 id="creating-key-packages"><a class="header" href="#creating-key-packages">Creating key packages</a></h2>
<p>Before clients can communicate with each other using OpenMLS they need to generate key packages and publish them with the Delivery Service. Clients can generate an arbitrary number of key packages ahead of time.</p>
<p>Clients keep the private key material corresponding to a key package locally in the key store and fetch it from there when a key package was used to add them to a new group.</p>
<p>Clients need to choose a few parameters to create a <code>KeyPackageBundle</code>:</p>
<ul>
<li><code>ciphersuites: &amp;[CiphersuiteName]</code>: A list of ciphersuites supported by the client.</li>
<li><code>extensions: Vec&lt;Extensions&gt;</code>: A list of supported extensions.</li>
</ul>
<p>Clients must specify at least one ciphersuite, and must not advertize ciphersuites they do not support.</p>
<p>Clients should specify all extensions they support. Mandatory extensions, like the <code>LifetimeExtension</code> can be specified here with specific values. If no extensions are specified, mandatory extensions are created on the fly with default values. See the documentation of extensions for more details.</p>
<pre><code class="language-rust no_run noplayground">    // Define extensions
    let extensions = vec![Extension::LifeTime(LifetimeExtension::new(
        60 * 60 * 24 * 90, // Maximum lifetime of 90 days, expressed in seconds
    ))];

    // Fetch the credential bundle from the key store
    let credential_bundle = backend
        .key_store()
        .read(
            &amp;credential
                .signature_key()
                .tls_serialize_detached()
                .expect(&quot;Error serializing signature key.&quot;),
        )
        .expect(&quot;An unexpected error occurred.&quot;);

    // Create the key package bundle
    let key_package_bundle =
        KeyPackageBundle::new(ciphersuites, &amp;credential_bundle, backend, extensions)?;
</code></pre>
<p>After creating the key package bundle, clients should store it in the key store so that it can be reused during group operations:</p>
<pre><code class="language-rust no_run noplayground">    let key_package = key_package_bundle.key_package().clone();

    // Store it in the key store
    backend
        .key_store()
        .store(
            key_package
                .hash_ref(backend.crypto())
                .expect(&quot;Could not hash KeyPackage.&quot;)
                .value(),
            &amp;key_package_bundle,
        )
        .expect(&quot;An unexpected error occurred.&quot;);
</code></pre>
<p>All functions and structs related to key packages can be found in the <a href="https://docs.rs/crate/openmls/latest/key_packages/index.html"><code>key_packages</code></a> module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="group-configuration"><a class="header" href="#group-configuration">Group configuration</a></h1>
<p>The group configuration can be specified by building a <code>MlsGroupConfig</code> object or choosing the default value. The default velaue contains safe values for all parameters and is suitable for scenarios whithout particular requirements.</p>
<p>The following parameters can be set:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>wire_format_policy</code></td><td><code>WireFormatPolicy</code></td><td>Defines the wire format policy for outgoing and incoming handshake messages.</td></tr>
<tr><td><code>padding_size</code></td><td><code>usize</code></td><td>Size of padding in bytes. The default is 0.</td></tr>
<tr><td><code>max_past_epochs</code></td><td><code>usize</code></td><td>Maximum number of past epochs for which application messages can be decrypted. The default is 0.</td></tr>
<tr><td><code>number_of_resumption_secrets</code></td><td><code>usize</code></td><td>Number of resumtion secrets to keep. The default is 0.</td></tr>
<tr><td><code>use_ratchet_tree_extension</code></td><td><code>bool</code></td><td>Flag indicating the Ratchet Tree Extension should be used. The default is <code>false</code>.</td></tr>
<tr><td><code>required_capabilities</code></td><td><code>RequiredCapabilitiesExtension</code></td><td>Required capabilities (extensions and proposal types).</td></tr>
<tr><td><code>sender_ratchet_configuration</code></td><td><code>SenderRatchetConfiguration</code></td><td>Sender ratchet configuration.</td></tr>
</tbody></table>
<p>Example configuration:</p>
<pre><code class="language-rust no_run noplayground">    let mls_group_config = MlsGroupConfig::builder()
        .padding_size(100)
        .sender_ratchet_configuration(SenderRatchetConfiguration::new(
            10,   // out_of_order_tolerance
            2000, // maximum_forward_distance
        ))
        .use_ratchet_tree_extension(true)
        .build();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-groups"><a class="header" href="#creating-groups">Creating groups</a></h1>
<p>Before a group can be created, a group configuration (<code>MlsGroupConfiguration</code>) needs to be defined. The default values of configuration parameters are picked for safety, however be sure to check all parameters carefully to ascertain if they match your implementation's requirements. See <a href="user_manual/group_config.html">Group configuration</a> for more details.</p>
<p>In addition to the group configuration, the client should define all supported and requitred extension for the group. The negotatiation mechanism for extension in MLS consists in setting an intial list of extensions at group creation time and choosing key packages of subsequent new members accordingly.</p>
<p>In practice, the supported and required extensions are set by adding them to the initial <code>KeyPackage</code> of the creator:</p>
<pre><code class="language-rust no_run noplayground">    // Define extensions
    let extensions = vec![Extension::LifeTime(LifetimeExtension::new(
        60 * 60 * 24 * 90, // Maximum lifetime of 90 days, expressed in seconds
    ))];

    // Fetch the credential bundle from the key store
    let credential_bundle = backend
        .key_store()
        .read(
            &amp;credential
                .signature_key()
                .tls_serialize_detached()
                .expect(&quot;Error serializing signature key.&quot;),
        )
        .expect(&quot;An unexpected error occurred.&quot;);

    // Create the key package bundle
    let key_package_bundle =
        KeyPackageBundle::new(ciphersuites, &amp;credential_bundle, backend, extensions)?;
</code></pre>
<p>Every group has a unique group ID that needs to be specified at the time of the group creation. The group ID cannot be changed after the group creation and therefore remains immutable throughout the group's lifetime. It should be chosen so that it doesn't collide with any other group IDs in the same system:</p>
<pre><code class="language-rust no_run noplayground">    let group_id = GroupId::from_slice(b&quot;Test Group&quot;);
</code></pre>
<p>After that the group can be created:</p>
<pre><code class="language-rust no_run noplayground">    let mut alice_group = MlsGroup::new(
        backend,
        &amp;mls_group_config,
        group_id,
        alice_key_package
            .hash_ref(backend.crypto())
            .expect(&quot;Could not hash KeyPackage.&quot;)
            .as_slice(),
    )
    .expect(&quot;An unexpected error occurred.&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join-a-group-from-a-welcome-message"><a class="header" href="#join-a-group-from-a-welcome-message">Join a group from a Welcome message</a></h1>
<p>To join a group from a <code>Welcome</code> message, a new <code>MlsGroup</code> can be instantiated directly from the <code>Welcome</code> message.
If the group configuration does not use the ratchet tree extension, the ratchet tree needs to be provided as well.</p>
<pre><code class="language-rust no_run noplayground">    let mut bob_group = MlsGroup::new_from_welcome(
        backend,
        &amp;mls_group_config,
        welcome,
        None, // We use the ratchet tree extension, so we don't provide a ratchet tree here
    )
    .expect(&quot;Error joining group from Welcome&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-members-to-a-group"><a class="header" href="#adding-members-to-a-group">Adding members to a group</a></h1>
<h2 id="immediate-operation"><a class="header" href="#immediate-operation">Immediate operation</a></h2>
<p>Members can be added to the group atomically with the <code>.add_members()</code> function. The application needs to fetch the corresponding key packages from every new member from the Delivery Service first.</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome) = alice_group
        .add_members(backend, &amp;[bob_key_package])
        .expect(&quot;Could not add members.&quot;);
</code></pre>
<p>The function returns the tuple <code>(MlsMessageOut, Welcome)</code>. The <code>MlsMessageOut</code> contains a Commit message that needs to be fanned out to existing members of the group. The <code>Welcome</code> message needs to be sent to the newly added members.</p>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>Members can also be added as a proposal (without the corresponding Commit message) by using the <code>.propose_add_member()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let mls_message_out = alice_group
        .propose_add_member(backend, &amp;bob_key_package)
        .expect(&quot;Could not create proposal to add Bob&quot;);
</code></pre>
<p>In this case the the function returns an <code>MlsMessageOut</code> that needs to be fanned out to existing group members.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removing-members-from-a-group"><a class="header" href="#removing-members-from-a-group">Removing members from a group</a></h1>
<h2 id="immediate-operation-1"><a class="header" href="#immediate-operation-1">Immediate operation</a></h2>
<p>Members can be removed from the group atomically with the <code>.remove_members()</code> function, which takes the <code>KeyPackageRef</code> of group member as input. References to the <code>KeyPackage</code>s of group members can be obtained using the <code>.members()</code> function, from which one can in turn compute the <code>KeyPackageRef</code> using their <code>.hash_ref()</code> function.</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome_option) = charlie_group
        .remove_members(backend, &amp;[bob_kp_ref])
        .expect(&quot;Could not remove Bob from group.&quot;);
</code></pre>
<p>The function returns the tuple <code>(MlsMessageOut, Option&lt;Welcome&gt;)</code>. The <code>MlsMessageOut</code> contains a Commit message that needs to be fanned out to existing members of the group.
Despite the fact that members were only removed in this operation, the Commit message could potentially also cover Add Proposals that were previously received in the epoch. Therefore the function can also optionally return a <code>Welcome</code> message. The <code>Welcome</code> message needs to be sent to the newly added members.</p>
<h2 id="proposal-1"><a class="header" href="#proposal-1">Proposal</a></h2>
<p>Members can also be removed as a proposal (without the corresponding Commit message) by using the <code>.propose_remove_member()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let mls_message_out = alice_group
        .propose_remove_member(
            backend,
            charlie_group
                .key_package_ref()
                .expect(&quot;An unexpected error occurred.&quot;),
        )
        .expect(&quot;Could not create proposal to remove Charlie.&quot;);
</code></pre>
<p>In this case the the function returns an <code>MlsMessageOut</code> that needs to be fanned out to existing group members.</p>
<h2 id="getting-removed-from-a-group"><a class="header" href="#getting-removed-from-a-group">Getting removed from a group</a></h2>
<p>A member is removed from a group if another member commits to a remove proposal targeting the member's leaf. Once the to-be-removed member merges that commit via <code>merge_staged_commit()</code>, all other proposals in that commit will still be applied but the group will be marked as inactive afterward. The group remains usable, e.g. to examine the membership list after the final commit was processed, but it won't be possible to create or process new messages.</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessage::StagedCommitMessage(staged_commit) = bob_processed_message {
        let remove_proposal = staged_commit
            .remove_proposals()
            .next()
            .expect(&quot;An unexpected error occurred.&quot;);

        // We construct a RemoveOperation enum to help us interpret the remove operation
        let remove_operation = RemoveOperation::new(remove_proposal, &amp;bob_group)
            .expect(&quot;An unexpected Error occurred.&quot;);

        match remove_operation {
            RemoveOperation::WeLeft =&gt; unreachable!(),
            // We expect this variant, since Bob was removed by Charlie
            RemoveOperation::WeWereRemovedBy(member) =&gt; {
                assert!(matches!(member, Sender::Member(member) if member == charlies_old_kpr));
            }
            RemoveOperation::TheyLeft(_) =&gt; unreachable!(),
            RemoveOperation::TheyWereRemovedBy(_) =&gt; unreachable!(),
            RemoveOperation::WeRemovedThem(_) =&gt; unreachable!(),
        }

        // Merge staged Commit
        bob_group
            .merge_staged_commit(*staged_commit)
            .expect(&quot;Could not merge Commit.&quot;);
    } else {
        unreachable!(&quot;Expected a StagedCommit.&quot;);
    }

    // Check we didn't receive a Welcome message
    assert!(welcome_option.is_none());

    // Check that Bob's group is no longer active
    assert!(!bob_group.is_active());
    let members = bob_group.members();
    assert_eq!(members.len(), 2);
    assert_eq!(members[0].credential().identity(), b&quot;Alice&quot;);
    assert_eq!(members[1].credential().identity(), b&quot;Charlie&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-own-key-package"><a class="header" href="#updating-own-key-package">Updating own key package</a></h1>
<h2 id="immediate-operation-2"><a class="header" href="#immediate-operation-2">Immediate operation</a></h2>
<p>Members can update their own leaf key package atomically with the <code>.self_update()</code> function.
The application can optionally provide a <code>KeyPackage</code> manually. If not, a key package will be created on the fly with the same extensions as the current one, but with a fresh HPKE init key.</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome_option) = bob_group
        .self_update(
            backend,
            None, // We don't provide a key package, it will be created on the fly instead
        )
        .expect(&quot;Could not update own key package.&quot;);
</code></pre>
<p>The function returns the tuple <code>(MlsMessageOut, Option&lt;Welcome&gt;)</code>. The <code>MlsMessageOut</code> contains a Commit message that needs to be fanned out to existing members of the group.
Despite the fact that the member only updates its own key package in this operation, the Commit message could potentially also cover Add Proposals that were previously received in the epoch. Therefore the function can also optionally return a <code>Welcome</code> message. The <code>Welcome</code> message needs to be sent to the newly added members.</p>
<h2 id="proposal-2"><a class="header" href="#proposal-2">Proposal</a></h2>
<p>Members can also update their key package as a proposal (without the corresponding Commit message) by using the <code>.propose_self_update()</code> function. Just like with the <code>.self_update()</code> function, an optional key package can be provided:</p>
<pre><code class="language-rust no_run noplayground">    let mls_message_out = alice_group
        .propose_self_update(
            backend,
            None, // We don't provide a key package, it will be created on the fly instead
        )
        .expect(&quot;Could not create update proposal.&quot;);
</code></pre>
<p>In this case the the function returns an <code>MlsMessageOut</code> that needs to be fanned out to existing group members.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leaving-a-group"><a class="header" href="#leaving-a-group">Leaving a group</a></h1>
<p>Members can indicate to the other members of the group that they wish to leave the group by using the <code>leave_group()</code> function, which creates a remove proposal targeting the member's own leaf. It is not possible for the member to create a Commit message that covers this proposal, as that would violate the Post-compromise Security guarantees of MLS because the member would know the epoch secrets of the next epoch.</p>
<pre><code class="language-rust no_run noplayground">    let queued_message = bob_group
        .leave_group(backend)
        .expect(&quot;Could not leave group&quot;);
</code></pre>
<p>After successfully sending the proposal to the DS for fanout, there is still the possibility that the remove proposal is not covered in the following commit. The member leaving the group thus has two options:</p>
<ul>
<li>tear down the local group state and ignore all subsequent messages for that group, or</li>
<li>wait for the commit to come through and process it (see also <a href="user_manual/remove_members.html#getting-removed-from-a-group">Getting Removed</a>).</li>
</ul>
<p>For details on how to create Remove Proposals, see <a href="user_manual/remove_members.html">Removing members from a group</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-application-messages"><a class="header" href="#creating-application-messages">Creating application messages</a></h1>
<p>Application messages are created from byte slices with the <code>.create_message()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let message_alice = b&quot;Hi, I'm Alice!&quot;;
    let mls_message_out = alice_group
        .create_message(backend, message_alice)
        .expect(&quot;Error creating application message.&quot;);
</code></pre>
<p>Note that the theoretical maximum length of application messages is 2^32 bytes, however in practice messages should be much shorter unless the Delivery Service can cope with very long messages.</p>
<p>The function returns an <code>MlsMessageOut</code> that needs to be sent to the Delivery Service for fanout to other members of the group. To guarantee the best possible Forward Secrecy, the key material used to encrypt messages is immediately discarded after encryption. This means that the message author cannot decrypt application messages. If access to the messages content is required after creating the message, a copy of the plaintext message should be kept by the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="committing-to-pending-proposals"><a class="header" href="#committing-to-pending-proposals">Committing to pending proposals</a></h1>
<p>During an epoch, members can create proposals that are not immediately committed. These proposals are called &quot;pending proposals&quot;. They will automatically be covered by any operation that creates a Commit message (like <code>.add_members(),</code> <code>.remove_members()</code>, etc.).</p>
<p>Some operations, (like creating application messages) are not allowed as long as pending proposals exist for the current epoch. In that case, the application needs to first commit to the pending proposals by creating a Commit message that covers these proposals. This can be done with the <code>commit_to_pending_proposals()</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let (mls_message_out, welcome_option) = alice_group
        .commit_to_pending_proposals(backend)
        .expect(&quot;Could not commit to pending proposals.&quot;);
</code></pre>
<p>The function returns the tuple <code>(MlsMessageOut, Option&lt;Welcome&gt;)</code>. The <code>MlsMessageOut</code> contains a Commit message that needs to be fanned out to existing members of the group.
In case the Commit message also covers Add Proposals that were previously received in the epoch, a <code>Welcome</code> message is required to invite the new members. Therefore the function can also optionally return a <code>Welcome</code> message. The <code>Welcome</code> message needs to be sent to the newly added members.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processing-incoming-messages"><a class="header" href="#processing-incoming-messages">Processing incoming messages</a></h1>
<p>Processing incoming messages happens in different phases:</p>
<h2 id="deserializing-messages"><a class="header" href="#deserializing-messages">Deserializing messages</a></h2>
<p>Incoming messages can be deserialized from byte slices into an <code>MlsMessageIn</code>:</p>
<pre><code class="language-rust no_run noplayground">    let mls_message_in =
        MlsMessageIn::try_from_bytes(&amp;bytes).expect(&quot;Could not deserialize message.&quot;);
</code></pre>
<p>If the message is malformed, the function will fail with an error.</p>
<h2 id="parsing-messages"><a class="header" href="#parsing-messages">Parsing messages</a></h2>
<p>In the next step, the incoming message needs to be parsed. If the message was encrypted, it will be decrypted automatically:</p>
<pre><code class="language-rust no_run noplayground">    let unverified_message = bob_group
        .parse_message(mls_message_in, backend)
        .expect(&quot;Could not parse message.&quot;);
</code></pre>
<p>Parsing can fail, if e.g. dercrypting the message fails. The exact reason for failure is returned in the error.</p>
<h2 id="processing-messages"><a class="header" href="#processing-messages">Processing messages</a></h2>
<p>In the next step the unverified message needs to be processed. This step performs all remaining validity checks and also verifies the message's signature. Optionally, a signature key can be provided to verify the message's signature. This can be used when processing external messages. By default, the sender's credential is used to verify the signature.</p>
<pre><code class="language-rust no_run noplayground">    let processed_message = bob_group
        .process_unverified_message(
            unverified_message,
            None, // No external signature key
            backend,
        )
        .expect(&quot;Could not process unverified message.&quot;);
</code></pre>
<h2 id="interpreting-the-processed-message"><a class="header" href="#interpreting-the-processed-message">Interpreting the processed message</a></h2>
<p>In the last step, the message is ready for inspection. There are 3 different kinds of messages:</p>
<h3 id="application-messages"><a class="header" href="#application-messages">Application messages</a></h3>
<p>Application messages simply return the original byte slice:</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessage::ApplicationMessage(application_message) = processed_message {
        // Check the message
        assert_eq!(application_message.into_bytes(), b&quot;Hi, I'm Alice!&quot;);
    }
</code></pre>
<h3 id="proposals"><a class="header" href="#proposals">Proposals</a></h3>
<p>Standalone proposals are returned as a <code>QueuedProposal</code>, indicating the fact that they are pending proposals. The actual proposal can be inspected through the <code>.proposal()</code> function. After inspection, applications should store the pending proposal in the proposal store of the group:</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessage::ProposalMessage(staged_proposal) = charlie_processed_message {
        // In the case we received an Add Proposal
        if let Proposal::Add(add_proposal) = staged_proposal.proposal() {
            // Check that Bob was added
            assert_eq!(add_proposal.key_package().credential(), &amp;bob_credential);
        } else {
            panic!(&quot;Expected an AddProposal.&quot;);
        }

        // Check that Alice added Bob
        assert!(matches!(
            staged_proposal.sender(),
            Sender::Member(member) if member == alice_group
            .key_package_ref()
            .expect(&quot;An unexpected error occurred.&quot;)
        ));
        // Store proposal
        charlie_group.store_pending_proposal(*staged_proposal);
    }
</code></pre>
<h3 id="commit-messages"><a class="header" href="#commit-messages">Commit messages</a></h3>
<p>Commit messages are returned as <code>StagedCommit</code> objects. The proposals they cover can be inspected through different functions, depending on the proposal type. For more details see the <code>StagedCommit</code> documentation. After the application has inspected the <code>StagedCommit</code> and approved all the proposals it covers, the <code>StagedCommit</code> can be merged in the current group state by calling the <code>.merge_staged_commit()</code> function.</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessage::StagedCommitMessage(staged_commit) = alice_processed_message {
        // We expect a remove proposal
        let remove = staged_commit
            .remove_proposals()
            .next()
            .expect(&quot;Expected a proposal.&quot;);
        // Check that Bob was removed
        assert_eq!(
            remove.remove_proposal().removed(),
            bob_group
                .key_package_ref()
                .expect(&quot;An unexpected error occurred.&quot;)
        );
        // Check that Charlie removed Bob
        assert!(matches!(
            remove.sender(),
            Sender::Member(member) if member == &amp;charlies_old_kpr
        ));
        // Merge staged commit
        alice_group
            .merge_staged_commit(*staged_commit)
            .expect(&quot;Could not merge Commit.&quot;);
    }
</code></pre>
<h3 id="interpreting-remove-operations"><a class="header" href="#interpreting-remove-operations">Interpreting remove operations</a></h3>
<p>Remove operations can have different meanings, such as:</p>
<ul>
<li>We left the group (by our own wish)</li>
<li>We were removed from the group (by another member or a pre-configured sender)</li>
<li>We removed another member from the group</li>
<li>Another member left the group (by its own wish)</li>
<li>Another member was removed from the group (by a member or a pre-configured sender, but not by us)</li>
</ul>
<p>Since all remove operations only appear as a <code>QueuedRemoveProposal</code>, the <code>RemoveOperation</code> enum can be constructed from the remove proposal and the current group state to refelect the different scenarios listed above.</p>
<pre><code class="language-rust no_run noplayground">    if let ProcessedMessage::StagedCommitMessage(staged_commit) = bob_processed_message {
        let remove_proposal = staged_commit
            .remove_proposals()
            .next()
            .expect(&quot;An unexpected error occurred.&quot;);

        // We construct a RemoveOperation enum to help us interpret the remove operation
        let remove_operation = RemoveOperation::new(remove_proposal, &amp;bob_group)
            .expect(&quot;An unexpected Error occurred.&quot;);

        match remove_operation {
            RemoveOperation::WeLeft =&gt; unreachable!(),
            // We expect this variant, since Bob was removed by Charlie
            RemoveOperation::WeWereRemovedBy(member) =&gt; {
                assert!(matches!(member, Sender::Member(member) if member == charlies_old_kpr));
            }
            RemoveOperation::TheyLeft(_) =&gt; unreachable!(),
            RemoveOperation::TheyWereRemovedBy(_) =&gt; unreachable!(),
            RemoveOperation::WeRemovedThem(_) =&gt; unreachable!(),
        }

        // Merge staged Commit
        bob_group
            .merge_staged_commit(*staged_commit)
            .expect(&quot;Could not merge Commit.&quot;);
    } else {
        unreachable!(&quot;Expected a StagedCommit.&quot;);
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="persistence-of-group-data"><a class="header" href="#persistence-of-group-data">Persistence of Group Data</a></h1>
<p>The state of a given <code>MlsGroup</code> instance can be written or read at any time using the <code>.save()</code> or <code>.load()</code> functions respectively. The functions take as input a struct implementing either the <code>Write</code> (<code>.save()</code>) or <code>Read</code> (<code>.load()</code>) trait.</p>
<p>Since some group operations might or might not change the <code>MlsGroup</code> state depending on the context, the group maintains the <code>state_changed</code> flag, which is set to <code>true</code> whenever the state is changed by an <code>MlsGroup</code> function. The state of the flag can be queried using the <code>.state_changed()</code> function.</p>
<h2 id="group-lockout-upon-state-loss"><a class="header" href="#group-lockout-upon-state-loss">Group Lockout Upon State Loss</a></h2>
<p>MLS provides strong Post-Compromise Security properties, which means that key material is regularly refreshed and old key material becomes stale very quickly. As a consequence, regularly persisting state is important, especially after the client has created a commit or issued an Update proposal, thus introducing new key material into the group. A loss of state in such a situation is only recoverable in specific cases, where the commit was rejected by the Delivery Service or if the proposed Update was not committed. To continue participating in a group after a loss of group state, a re-join is required in most cases. To avoid a loss of state and the associated re-join, persisting <code>MlsGroup</code> state after each state-changing group operation is mandatory.</p>
<h2 id="forward-secrecy-considerations"><a class="header" href="#forward-secrecy-considerations">Forward-Secrecy Considerations</a></h2>
<p>The <code>MlsGroup</code> state that is persisted using the <code>.save()</code> function contains private key material. As a consequence, the application needs to delete old group states to achieve Forward-Secrecy w.r.t. that key material. Since, as detailed above, an old group state is stale immediately after most group operations, we recommend deleting old group states as soon as a new one was written.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits--external-types"><a class="header" href="#traits--external-types">Traits &amp; External Types</a></h1>
<p>OpenMLS defines a number of traits that have to be implemented in order to use
OpenMLS.
The main goal is to allow OpenMLS to use different implementations for its
cryptographic primitives, persistence and random number generation.
This should make it possible to plug in anything from <a href="https://www.w3.org/TR/WebCryptoAPI/">WebCrypto</a> to secure
enclaves.</p>
<ul>
<li><a href="traits/./traits.html">Traits</a></li>
<li><a href="traits/./types.html">External Types</a></li>
</ul>
<h2 id="using-the-key-store"><a class="header" href="#using-the-key-store">Using the key store</a></h2>
<p>The key store is probably one of the most interesting traits because applications
that use OpenMLS will interact with it.
See the <a href="traits/./traits.html#openmlskeystore">OpenMlsKeyStore trait</a> description for details
but note that the key used to store, read, and delete values in the key store has
to be provided as a byte slice.</p>
<p>In the following examples we have a <code>ciphersuite</code> and a <code>backend</code> (<code>OpenMlsCryptoProvider</code>).</p>
<pre><code class="language-rust no_run noplayground">    // First we generate a credential and key package for our user.
    let credential_bundle = CredentialBundle::new(
        b&quot;User ID&quot;.to_vec(),
        CredentialType::Basic,
        SignatureScheme::from(ciphersuite),
        backend,
    )
    .unwrap();
    let key_package_bundle =
        KeyPackageBundle::new(&amp;[ciphersuite], &amp;credential_bundle, backend, vec![])
            .expect(&quot;Error generating new key package bundle.&quot;);

    // In order to store something in the key store we need to define an ID.
    // Here we simply take the key package reference.
    let id = key_package_bundle
        .key_package()
        .hash_ref(backend.crypto())
        .expect(&quot;Failed to hash KeyPackage.&quot;);

    // Now we can store the key_package_bundle.
    backend
        .key_store()
        .store(id.as_slice(), &amp;key_package_bundle)
        .expect(&quot;Failed to store key package bundle in keystore.&quot;);
</code></pre>
<p>In order to delete a value the <code>delete</code> is called with the identifier.</p>
<pre><code class="language-rust no_run noplayground">    // Delete the key package bundle.
    backend
        .key_store()
        .delete(id.as_slice())
        .expect(&quot;Error deleting key package bundle&quot;);
</code></pre>
<p>Retrieving a value from the key store is as simple as calling <code>read</code>.
In this example we assume that we got a <code>credential</code> where we want to retrieve
the credential bundle for, i.e. the private key material.</p>
<pre><code class="language-rust no_run noplayground">    // In order to read something from the key store we need to define an ID.
    // Here we simply take the serialized public key of the credential.
    let id = credential
        .signature_key()
        .tls_serialize_detached()
        .expect(&quot;Error serializing the credential's public key.&quot;);

    let credential_bundle: CredentialBundle = backend
        .key_store()
        .read(&amp;id)
        .expect(&quot;Error retrieving the credential bundle&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openmls-traits"><a class="header" href="#openmls-traits">OpenMLS Traits</a></h1>
<blockquote>
<p><strong>⚠️  These traits are responsible for all cryptographic operations and randomness
within OpenMLS.
Please ensure you know what you're doing when implementing your own versions.</strong></p>
</blockquote>
<p>Because implementing the <code>OpenMLSCryptoProvider</code> is challenging, requires
tremendous care, and is not what the average OpenMLS consumer wants to (or should) do,
we provide two implementations that can be used.</p>
<ul>
<li><a href="https://crates.io/crates/openmls_rust_crypto">Rust Crypto</a></li>
<li><a href="https://crates.io/crates/openmls_evercrypt_backend">Evercrypt</a></li>
</ul>
<p><strong>Rust Crypto Provider</strong>
The go-to default at the moment is an implementation using commonly used, native Rust
crypto implementations.</p>
<p><strong>Evercrypt Provider</strong>
In addition to the Rust Crypto Provider there's the Evercrypt provider that uses
the formally verified HACL*/Evercrypt library.
Note that this provider does not work equally well on all platforms yet.</p>
<h2 id="the-traits"><a class="header" href="#the-traits">The Traits</a></h2>
<p>There are 4 different traits defined in the <a href="https://crates.io/crates/openmls_traits">OpenMLS traits crate</a>.</p>
<h3 id="openmlsrand"><a class="header" href="#openmlsrand">OpenMlsRand</a></h3>
<p>This trait defines two functions to generate arrays and vectors, and is used by
OpenMLS to generate randomness for key generation and random identifiers.
While there is the commonly used <a href="https://crates.io/crates/rand">rand crate</a> not all implementations use it.
OpenMLS therefore defines its own randomness trait that needs to be implemented
by an OpenMLS crypto provider.
It simply needs to implement two functions to generate cryptographically secure
randomness and store it into an array or vector.</p>
<pre><code class="language-rust no_run noplayground">pub trait OpenMlsRand {
    type Error: Debug + Clone + PartialEq + Into&lt;String&gt;;

    /// Fill an array with random bytes.
    fn random_array&lt;const N: usize&gt;(&amp;self) -&gt; Result&lt;[u8; N], Self::Error&gt;;

    /// Fill a vector of length `len` with bytes.
    fn random_vec(&amp;self, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt;;
}
</code></pre>
<h3 id="openmlscrypto"><a class="header" href="#openmlscrypto">OpenMlsCrypto</a></h3>
<p>This trait defines all cryptographic functions required by OpenMLS, in particular</p>
<ul>
<li>HKDF</li>
<li>Hashing</li>
<li>AEAD</li>
<li>Signatures</li>
<li>HPKE</li>
</ul>
<pre><code class="language-rust no_run noplayground">pub trait OpenMlsCrypto {
</code></pre>
<h3 id="openmlskeystore"><a class="header" href="#openmlskeystore">OpenMlsKeyStore</a></h3>
<p>This trait defines a CRUD API for a key store that is used to store long-term
key material from OpenMLS.</p>
<p>The key store provides functions to <code>store</code>, <code>read</code> and <code>delete</code> values.
Note that it does not allow to update values.
Instead entries must be deleted and newly stored.</p>
<pre><code class="language-rust no_run noplayground">/// The Key Store trait
pub trait OpenMlsKeyStore: Send + Sync {
    /// The error type returned by the [`OpenMlsKeyStore`].
    type Error: Debug + Clone + PartialEq + Into&lt;String&gt;;

    /// Store a value `v` that implements the [`ToKeyStoreValue`] trait for
    /// serialization for ID `k`.
    ///
    /// Returns an error if storing fails.
    fn store&lt;V: ToKeyStoreValue&gt;(&amp;self, k: &amp;[u8], v: &amp;V) -&gt; Result&lt;(), Self::Error&gt;
    where
        Self: Sized;

    /// Read and return a value stored for ID `k` that implements the
    /// [`FromKeyStoreValue`] trait for deserialization.
    ///
    /// Returns [`None`] if no value is stored for `k` or reading fails.
    fn read&lt;V: FromKeyStoreValue&gt;(&amp;self, k: &amp;[u8]) -&gt; Option&lt;V&gt;
    where
        Self: Sized;

    /// Delete a value stored for ID `k`.
    ///
    /// Returns an error if storing fails.
    fn delete(&amp;self, k: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt;;
}
</code></pre>
<p><strong>NOTE:</strong> Right now key material needs to be extractable from the key store.
This will most likely change in the future.</p>
<h3 id="openmlscryptoprovider"><a class="header" href="#openmlscryptoprovider">OpenMlsCryptoProvider</a></h3>
<p>Additionally, there's a wrapper trait defined that is expected to be passed into
the public OpenMLS API.
Some OpenMLS APIs require only one of the sub-traits though.</p>
<pre><code class="language-rust no_run noplayground">pub trait OpenMlsCryptoProvider: Send + Sync {
    type CryptoProvider: crypto::OpenMlsCrypto;
    type RandProvider: random::OpenMlsRand;
    type KeyStoreProvider: key_store::OpenMlsKeyStore;

    /// Get the crypto provider.
    fn crypto(&amp;self) -&gt; &amp;Self::CryptoProvider;

    /// Get the randomness provider.
    fn rand(&amp;self) -&gt; &amp;Self::RandProvider;

    /// Get the key store provider.
    fn key_store(&amp;self) -&gt; &amp;Self::KeyStoreProvider;
}
</code></pre>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>It is not necessary to implement all sub-traits if one functionality is missing.
If you want to use a persisting key store for example, it is sufficient to do a new implementation of the key store trait and combine it with one of the provided crypto and randomness trait implementations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-types"><a class="header" href="#external-types">External Types</a></h1>
<p>For interoperability this crate also defines a number of types and algorithm
identifiers.</p>
<p><strong>AEADs</strong></p>
<p>The following AEADs are defined.</p>
<pre><code class="language-rust no_run noplayground">pub enum AeadType {
    /// AES GCM 128
    Aes128Gcm = 0x0001,

    /// AES GCM 256
    Aes256Gcm = 0x0002,

    /// ChaCha20 Poly1305
    ChaCha20Poly1305 = 0x0003,
}
</code></pre>
<p>An AEAD provides the following functions to get the according values for each
algorithm.</p>
<ul>
<li><code>tag_size</code></li>
<li><code>key_size</code></li>
<li><code>nonce_size</code></li>
</ul>
<p><strong>Hashing</strong></p>
<p>The following hash algorithms are defined.</p>
<pre><code class="language-rust no_run noplayground">pub enum HashType {
    Sha2_256 = 0x04,
    Sha2_384 = 0x05,
    Sha2_512 = 0x06,
}
</code></pre>
<p>An hash algorithm provides the following functions to get the according values for each
algorithm.</p>
<ul>
<li><code>size</code></li>
</ul>
<p><strong>Signatures</strong></p>
<p>The following signature schemes are defined.</p>
<pre><code class="language-rust no_run noplayground">pub enum SignatureScheme {
    /// ECDSA_SECP256R1_SHA256
    ECDSA_SECP256R1_SHA256 = 0x0403,
    /// ECDSA_SECP384R1_SHA384
    ECDSA_SECP384R1_SHA384 = 0x0503,
    /// ECDSA_SECP521R1_SHA512
    ECDSA_SECP521R1_SHA512 = 0x0603,
    /// ED25519
    ED25519 = 0x0807,
    /// ED448
    ED448 = 0x0808,
}
</code></pre>
<h1 id="hpke-types"><a class="header" href="#hpke-types">HPKE Types</a></h1>
<p>The HPKE implementation is part of the crypto provider as well.
The crate therefore defines the necessary types too.</p>
<p>The HPKE algorithms are defined as follows.</p>
<pre><code class="language-rust no_run noplayground">#[repr(u16)]
pub enum HpkeKemType {
    /// DH KEM on P256
    DhKemP256 = 0x0010,

    /// DH KEM on P384
    DhKemP384 = 0x0011,

    /// DH KEM on P521
    DhKemP521 = 0x0012,

    /// DH KEM on x25519
    DhKem25519 = 0x0020,

    /// DH KEM on x448
    DhKem448 = 0x0021,
</code></pre>
<pre><code class="language-rust no_run noplayground">#[repr(u16)]
pub enum HpkeKdfType {
    /// HKDF SHA 256
    HkdfSha256 = 0x0001,

    /// HKDF SHA 384
    HkdfSha384 = 0x0002,

    /// HKDF SHA 512
    HkdfSha512 = 0x0003,
</code></pre>
<pre><code class="language-rust no_run noplayground">#[repr(u16)]
pub enum HpkeAeadType {
    /// AES GCM 128
    AesGcm128 = 0x0001,

    /// AES GCM 256
    AesGcm256 = 0x0002,

    /// ChaCha20 Poly1305
    ChaCha20Poly1305 = 0x0003,

    /// Export-only
    Export = 0xFFFF,
</code></pre>
<p>In addition helper structs for <code>HpkeCiphertext</code> and <code>HpkeKeyPair</code> are defined.</p>
<pre><code class="language-rust no_run noplayground">)]
pub struct HpkeCiphertext {
    pub kem_output: TlsByteVecU16,
    pub ciphertext: TlsByteVecU16,
</code></pre>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone)]
pub struct HpkeKeyPair {
    pub private: Vec&lt;u8&gt;,
    pub public: Vec&lt;u8&gt;,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-validation"><a class="header" href="#message-validation">Message Validation</a></h1>
<p>OpenMLS implements a variety of syntactical and semantical checks, both when parsing and processing incoming commits and when creating own commits.</p>
<h2 id="validation-steps"><a class="header" href="#validation-steps">Validation steps</a></h2>
<p>Validation is enforced using Rust's type system. The chain of functions used to process incoming messages is described in the chapter on <a href="user_manual/processing.html">Processing incoming messages</a>, where each function takes a distinct type as input and produces a distinct type as output, thus ensuring that the individual steps can't be skipped. We now detail which step performs which validation checks.</p>
<h3 id="syntax-validation"><a class="header" href="#syntax-validation">Syntax validation</a></h3>
<p>Incoming messages in the shape of a byte string can only be deserialized into a <code>MlsMessageIn</code> struct. Deserialization ensures that the message is a syntactically correct MLS message, i.e. either an MLSPlaintext or an MLSCiphertext.
For the latter case, further syntax checks are applied once the message is decrypted.</p>
<h3 id="semantic-validation"><a class="header" href="#semantic-validation">Semantic validation</a></h3>
<p>Every function in the processing chain performs a number of semantic validation steps. For a list of these steps, see <a href="message_validation.html#detailed-list-of-validation-steps">below</a>. In the following, we will give a brief overview over which function performs which category of checks.</p>
<h4 id="wire-format-policy-and-basic-message-consistency-validation"><a class="header" href="#wire-format-policy-and-basic-message-consistency-validation">Wire format policy and basic message consistency validation</a></h4>
<p><code>MlsMessageIn</code> struct instances can be passed into the <code>.parse_message()</code> function of the <code>MlsGroup</code> API, which validates that the message conforms to the group's <a href="user_manual/group_config.html">wire format policy</a> (<code>ValSem001</code>). The function also performs a number of basic semantic validation steps, such as consistency of Group id, Epoch and Sender data between message and group (<code>ValSem002</code>-<code>ValSem007</code> and <code>ValSem109</code>). It also checks if the sender type (e.g. <code>Member</code>, <code>NewMember</code>, etc.) matches the type of the message (<code>ValSem112</code>), as well as the presence of a path in case of an External Commit (<code>ValSem246</code>).</p>
<p><code>.parse_message()</code> then returns an <code>UnverifiedMessage</code> struct instance, which can in turn be used as input for <code>.process_unverified_message()</code>.</p>
<h4 id="message-specific-semantic-validation"><a class="header" href="#message-specific-semantic-validation">Message-specific semantic validation</a></h4>
<p><code>.process_unverified_message()</code> performs all other semantic validation steps. In particular, it ensures that</p>
<ul>
<li>the message is properly authenticated by signature (<code>ValSem010</code>), membership tag (<code>ValSem008</code>) and confirmation tag (<code>ValSem205</code>),</li>
<li>proposals are valid relative to one-another and the current group state, e.g. no redundant adds or removes targeting non-members (<code>ValSem100</code>-<code>ValSem112</code>),</li>
<li>commits are valid relative to the group state and the proposals it covers (<code>ValSem200</code>-<code>ValSem205</code>) and</li>
<li>external commits are valid according to the spec (<code>ValSem240</code>-<code>ValSem245</code>, <code>ValSem247</code> is checked as part of <code>ValSem010</code>).</li>
</ul>
<p>After performing these steps, messages are returned as <code>ProcessedMessage</code>s that the application can either use immediately (application messages) or inspect and decide if they find them valid according to the application's own policy (proposals and commits). Proposals can then be stored in the proposal queue via <code>.store_pending_proposal()</code>, while commits can be merged into the group state via <code>.merge_staged_commit()</code>.</p>
<h2 id="detailed-list-of-validation-steps"><a class="header" href="#detailed-list-of-validation-steps">Detailed list of validation steps</a></h2>
<p>The following is a list of the individual semantic validation steps performed by OpenMLS, including the location of the tests.</p>
<h3 id="semantic-validation-of-message-framing"><a class="header" href="#semantic-validation-of-message-framing">Semantic validation of message framing</a></h3>
<table><thead><tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr></thead><tbody>
<tr><td><code>ValSem001</code></td><td>Wire format</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem002</code></td><td>Group id</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem003</code></td><td>Epoch</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem004</code></td><td>Sender: Member: check the sender points to a non-blank leaf</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem005</code></td><td>Application messages must use ciphertext</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem006</code></td><td>Ciphertext: decryption needs to work</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem007</code></td><td>Membership tag presence</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem008</code></td><td>Membership tag verification</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem009</code></td><td>Confirmation tag presence</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
<tr><td><code>ValSem010</code></td><td>Signature verification</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_framing_validation.rs</code></td></tr>
</tbody></table>
<h3 id="semantic-validation-of-proposals-covered-by-a-commit"><a class="header" href="#semantic-validation-of-proposals-covered-by-a-commit">Semantic validation of proposals covered by a Commit</a></h3>
<table><thead><tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr></thead><tbody>
<tr><td><code>ValSem100</code></td><td>Add Proposal: Identity in proposals must be unique among proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem101</code></td><td>Add Proposal: Signature public key in proposals must be unique among proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem102</code></td><td>Add Proposal: HPKE init key in proposals must be unique among proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem103</code></td><td>Add Proposal: Identity in proposals must be unique among existing group members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem104</code></td><td>Add Proposal: Signature public key in proposals must be unique among existing group members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem105</code></td><td>Add Proposal: HPKE init key in proposals must be unique among existing group members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem106</code></td><td>Add Proposal: required capabilities</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem107</code></td><td>Remove Proposal: Removed member must be unique among proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem108</code></td><td>Remove Proposal: Removed member must be an existing group member</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem109</code></td><td>Update Proposal: Identity must be unchanged between existing member and new proposal</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem110</code></td><td>Update Proposal: HPKE init key must be unique among existing members</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem111</code></td><td>Update Proposal: The sender of a full Commit must not include own update proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
<tr><td><code>ValSem112</code></td><td>Update Proposal: The sender of a standalone update proposal must be of type member</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_proposal_validation.rs</code></td></tr>
</tbody></table>
<h3 id="commit-message-validation"><a class="header" href="#commit-message-validation">Commit message validation</a></h3>
<table><thead><tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr></thead><tbody>
<tr><td><code>ValSem200</code></td><td>Commit must not cover inline self Remove proposal</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem201</code></td><td>Path must be present, if Commit contains Removes or Updates</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem202</code></td><td>Path must be the right length</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem203</code></td><td>Path secrets must decrypt correctly</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem204</code></td><td>Public keys from Path must be verified and match the private keys from the direct path</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem205</code></td><td>Confirmation tag must be successfully verified</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_commit_validation.rs</code></td></tr>
</tbody></table>
<h3 id="external-commit-message-validation"><a class="header" href="#external-commit-message-validation">External Commit message validation</a></h3>
<table><thead><tr><th>ValidationStep</th><th>Description</th><th>Implemented</th><th>Tested</th><th>Test File</th></tr></thead><tbody>
<tr><td><code>ValSem240</code></td><td>External Commit must cover at least one inline ExternalInit proposal</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem241</code></td><td>External Commit must cover at most one inline ExternalInit proposal</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem242</code></td><td>External Commit must not cover any inline Add proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem243</code></td><td>External Commit must not cover any inline Update proposals</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem244</code></td><td>Identity of inline Remove proposal target and external committer must be the same</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem245</code></td><td>External Commit must not cover any ExternalInit proposals by reference</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem246</code></td><td>External Commit must contain a path</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
<tr><td><code>ValSem247</code></td><td>External Commit signature must be verified using the credential in the path KeyPackage</td><td>✅</td><td>✅</td><td><code>openmls/src/group/tests/test_external_commit_validation.rs</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<p>How does OpenMLS (and MLS in general) perform in different settings?</p>
<p>Performance measurements are implemented <a href="https://github.com/openmls/openmls/blob/franziskus/benchmarks/benches/group.rs">here</a> and can be run with <code>cargo bench --bench group</code>.
Make sure that check in the code which scenarios and group sizes are enabled.</p>
<p><a href="https://docs.google.com/spreadsheets/d/1nZv8lpT28JctDVo4ARBLZCKcIdvo-h8cIyN3_dIedFU">OpenMLS Performance Spreadsheet</a></p>
<h2 id="real-world-scenarios"><a class="header" href="#real-world-scenarios">Real World Scenarios</a></h2>
<h3 id="stable-group"><a class="header" href="#stable-group">Stable group</a></h3>
<p>Many private groups follow this model</p>
<ul>
<li>Group is created by user P1</li>
<li>P1 invites a set of N other users</li>
<li>The group is used for messaging between the N+1 members</li>
<li>Every X messages one user in the group sends an update</li>
</ul>
<h3 id="somewhat-stable-group"><a class="header" href="#somewhat-stable-group">Somewhat stable group</a></h3>
<p>This can model a company or team wide group where regularly but infrequently users are added and users leave</p>
<ul>
<li>Group is created by user P1</li>
<li>P1 invites a set of N other users</li>
<li>The group is used for messaging between the members</li>
<li>Every X messages one user in the group sends an update</li>
<li>Every Y messages Q users are added</li>
<li>Every Z messages R users are removed</li>
</ul>
<h3 id="high-fluctuation-group"><a class="header" href="#high-fluctuation-group">High fluctuation group</a></h3>
<p>This models public groups where users frequently join and leave.
Real-time scenarios such as <a href="https://gather.town">gather.town</a> are an example of high fluctuation groups.
It is the same scenario as the somewhat stable group but with a very small Y, Z.</p>
<h2 id="extreme-scenarios"><a class="header" href="#extreme-scenarios">Extreme Scenarios</a></h2>
<p>In addition to the three scenarios above extreme and corner cases are interesting.</p>
<h3 id="every-second-leave-is-blank"><a class="header" href="#every-second-leave-is-blank">Every second leave is blank</a></h3>
<p>Only every second leave in the tree is non-blank.</p>
<h2 id="use-case-scenarios"><a class="header" href="#use-case-scenarios">Use Case Scenarios</a></h2>
<p>A collection of common use cases/flows.</p>
<h3 id="long-time-offline-device"><a class="header" href="#long-time-offline-device">Long-time offline device</a></h3>
<p>If a device has been offline for a while, it has to process a large number of application and protocol messages.</p>
<h2 id="tree-scenarios"><a class="header" href="#tree-scenarios">Tree scenarios</a></h2>
<p>In addition the scenarios above it is interesting to look at the same scenario but with different states of the tree.
For example, take the stable group with N members messaging each other.
How is the performance different between a message sent right after group setup, i.e. each member only joined the group without other messages being sent, and a tree where every member has sent an update before the message?</p>
<h2 id="measurements"><a class="header" href="#measurements">Measurements</a></h2>
<ul>
<li>Group creation
<ul>
<li>create group</li>
<li>create proposals</li>
<li>create welcome</li>
<li>apply commit</li>
</ul>
</li>
<li>Join group
<ul>
<li>create group from welcome</li>
</ul>
</li>
<li>Send application message</li>
<li>Receive application message</li>
<li>Send update
<ul>
<li>create proposal</li>
<li>create commit</li>
<li>apply commit</li>
</ul>
</li>
<li>Receive update
<ul>
<li>apply commit</li>
</ul>
</li>
<li>Add user sender
<ul>
<li>create proposal</li>
<li>create welcome</li>
<li>apply commit</li>
</ul>
</li>
<li>Existing user getting an add
<ul>
<li>apply commit</li>
</ul>
</li>
<li>Remove user sender
<ul>
<li>create proposal</li>
<li>create commit</li>
<li>apply commit</li>
</ul>
</li>
<li>Existing user getting a remove
<ul>
<li>apply commit</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forward-secrecy"><a class="header" href="#forward-secrecy">Forward Secrecy</a></h1>
<p>To achieve forward secrecy, OpenMLS drops key material immediately after a given
key is no longer required by the protocol. For some keys this is simple, as they
are used only once and there is no need to store them for later use. However,
for other keys, the time of deletion is a result of a trade-off between
functionality and forward secrecy. For example, it can be desirable to keep the
<code>SecretTree</code> of past epochs for a while to allow decryption of straggling
application messages sent in previous epochs.</p>
<p>In this chapter, we detail how we achieve forward secrecy for the different types of keys used throughout MLS.</p>
<h2 id="ratchet-tree"><a class="header" href="#ratchet-tree">Ratchet Tree</a></h2>
<p>The ratchet tree contains the secret key material of the client's leaf, as well
(potentially) that of nodes in its direct path. The secrets in the tree are
changed in the same way as the tree itself: via the merge of a previously
prepared diff.</p>
<h3 id="commit-creation"><a class="header" href="#commit-creation">Commit Creation</a></h3>
<p>Upon the creation of a commit, any fresh key material introduced by the
committer is stored in the diff. It exists alongside the key material of the
ratchet tree before the commit until the client merges the diff, upon which the
key material in the original ratchet tree is dropped.</p>
<h3 id="commit-processing"><a class="header" href="#commit-processing">Commit Processing</a></h3>
<p>Upon receiving a commit from another group member, the client processes the
commit until they have a <code>StagedCommit</code>, which in turn contains a ratchet tree
diff. The diff contains any potential key material they decrypted from the
commit, as well as any potential key material that was introduced to the tree as
part of an update that someone else committed for them. The key material in the
original ratchet tree is dropped as soon as the <code>StagedCommit</code> (and thus the
diff) is merged into the tree.</p>
<h3 id="sending-application-messages"><a class="header" href="#sending-application-messages">Sending application messages</a></h3>
<p>When an application message is created, the corresponding encryption key is derived from the <code>SecretTree</code> and immediately discarded after encrypting the message to guarantee the best possible Forward Secrecy. This means that the message author cannot decrypt application messages. If access to the messages content is required after creating the message, a copy of the plaintext message should be kept by the application.</p>
<h3 id="receiving-encrypted-messages"><a class="header" href="#receiving-encrypted-messages">Receiving encrypted messages</a></h3>
<p>When an encrypted message is received, the corresponding decryption key is derived from the <code>SecretTree</code>. By default, the key material is discarded immediately after decryption for the best possible Forward Secrecy. In some cases, the Delivery Service cannot guarantee reliable operation and applications need to be more tolerant to accomodate this – at the expense of Forward Secrecy.</p>
<p>OpenMLS can address 3 scenarios:</p>
<ul>
<li>
<p>The Delivery Service cannot guarantee that application messages from one epoch are sent before the beginning of the next epoch. To address this, applications can configure their groups to keep the necessary key material around for past epochs by setting the <code>max_past_epochs</code> field in the <code>MlsGroupConfig</code> to the desired number of epochs.</p>
</li>
<li>
<p>The Delivery Service cannot guarantee that application messages will arrive in order within the same epoch. To address this, applications can configure the <code>out_of_order_tolerance</code> parameter of the <code>SenderRatchetConfiguration</code>. The configuration can be set as the <code>sender_ratchet_configuration</code> parameter of the <code>MlsGroupConfig</code>.</p>
</li>
<li>
<p>The Delivery Service cannot guarantee that application messages won't be dropped within the same epoch. To address this, applications can configure the <code>maximum_forward_distance</code> parameter of the <code>SenderRatchetConfiguration</code>. The configuration can be set as the <code>sender_ratchet_configuration</code> parameter of the <code>MlsGroupConfig</code>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-management"><a class="header" href="#release-management">Release management</a></h1>
<p>The process for releasing a new version of OpenMLS.</p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>The versioning follows the Rust and semantic <a href="https://semver.org">versioning guidelines</a>.</p>
<h2 id="release-notes"><a class="header" href="#release-notes">Release Notes</a></h2>
<p>Release notes are published on Github with a full changelog and a discussion in
the &quot;Release&quot; section.
In addition the release notes are prepended to the CHANGELOG file in each crate's
root folder.
The entries in the CHANGELOG file should follow the <a href="https://keepachangelog.com/en/1.0.0/">keep a changelog guide</a>.</p>
<h2 id="pre-release-strategy"><a class="header" href="#pre-release-strategy">Pre-release strategy</a></h2>
<p>Before releasing a minor or major version of the OpenMLS crate a pre-release version
must be published to crates.io.
Pre-release versions are defined by appending a hyphen and a series of dot
separated identifiers, i.e. <code>-pre.x</code> where <code>x</code> gets counted up starting at 1.
Pre-releases must get tagged but don't require release notes or any other documentation.
It is also sufficient to tag only for the most high-level crate being published.</p>
<hr />
<h2 id="crates-in-this-repository"><a class="header" href="#crates-in-this-repository">Crates in this Repository</a></h2>
<p>It is important that the crates are publish in the order below.</p>
<ul>
<li><a href="https://github.com/openmls/openmls/blob/main/traits/Cargo.toml">Traits</a></li>
<li><a href="https://github.com/openmls/openmls/blob/main/memory_keystore/Cargo.toml">Memory Keystore</a></li>
<li><a href="https://github.com/openmls/openmls/blob/main/openmls_rust_crypto/Cargo.toml">Rust Crypto Backend</a></li>
<li><a href="https://github.com/openmls/openmls/blob/main/evercrypt_backend/Cargo.toml">Evercrypt Backend</a></li>
<li><a href="https://github.com/openmls/openmls/blob/main/openmls/Cargo.toml">OpenMLS</a></li>
</ul>
<h2 id="release-note-and-changelog-template"><a class="header" href="#release-note-and-changelog-template">Release note and changelog template</a></h2>
<pre><code class="language-markdown">## 0.0.0 (2022-02-22)

### Added

- the feature ([#000])

### Changed

- the change ([#000])

### Deprecated

- the deprecated feature ([#000])

### Removed

- the removed feature ([#000])

### Fixed

- the fixed bug ([#000])

### Security

- the fixed security bug ([#000])

[#000]: https://github.com/openmls/openmls/pull/000
</code></pre>
<h2 id="release-checklist"><a class="header" href="#release-checklist">Release checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
If this is a minor or major release, has a pre-release version been published at least a week before the release?
<ul>
<li>If not, first do so and push the release one week.</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Describe the release in the CHANGELOG.</li>
<li><input disabled="" type="checkbox"/>
Create and publish a git tag for each crate, e.g. <code>openmls/v0.4.0-pre.1</code>.</li>
<li><input disabled="" type="checkbox"/>
Create and publish release notes on Github.</li>
<li><input disabled="" type="checkbox"/>
Publish the crates to crates.io</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
